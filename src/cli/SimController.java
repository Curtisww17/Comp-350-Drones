package cli;

import menu.DefaultFood;
import menu.Destination;
import menu.Meal;
import org.w3c.dom.ranges.Range;

import java.io.*;
import java.util.ArrayList;
import java.util.List;
import java.util.Random;
import java.util.Scanner;

public class SimController {
    File nameFile; //File that contains a list of names
    ArrayList<String> names; //Stores the list of names
    File ordersFile; //xml file that saves the orders
    private static DefaultFood defaultFood; //The object that stores the default meal combos

    ArrayList<PlacedOrder> test;

    //pointer to the single instance of SimController
    private static SimController single_instance = null;


    private SimController() {
        test = new ArrayList<>();

        names = new ArrayList<>();
        try {
            //Names.txt was generated by Dominic Tarr
            nameFile = new File("Names.txt"); //open the names file

            //Seed the arraylist with names in the file
            Scanner s = new Scanner(nameFile);
            while(s.hasNext()) {
                names.add(s.next());
            }
            s.close();

        } catch (Exception e) {
            System.out.println((e.getMessage()));
        }

        defaultFood = new DefaultFood(); //Get the default food settings
        //System.out.println(defaultFood.mapToString());
    }

    //Singleton creator
    public static SimController getInstance() {
        if (single_instance == null) {
            single_instance = new SimController();
        }
        return single_instance;
    }

    /**
     * Generates the orders for the four hour simulation
     * The orders are stored in Orders.xml
     */
    public void generateOrders() {
        Random random = new Random(); //new random generator

        int minutesInSim = 240; //The number of minutes in the simulation
        int curMin = 0; //The current minute the simulation is in
        int randName; //random integer for what name to choose the ArrayList
        ArrayList<Destination> map = defaultFood.getMap(); //Map of the given campus
        Meal m; //Current meal being ordered
        Destination d; //The destination to be delivered to


        //open the orders file
        try{
            ordersFile = new File("Orders.xml");
            FileWriter fileWriter = new FileWriter(ordersFile, false); //clear out the orders file
            PrintWriter printWriter = new PrintWriter(fileWriter);
            printWriter.println("<listOfOrders>");
            printWriter.close();
        } catch (Exception e) {
            System.out.println(e.getMessage());
        }

        double chanceOfOrderPerM = .25; //Set to .25 as default
        //calculate the chance of order per minute

        //For each minute in the simulation
        while (curMin < minutesInSim) {

            if (random.nextDouble() < chanceOfOrderPerM) { //If the probability is low enough, generate an order
                //Get a random name
                randName = random.nextInt(names.size());

                //Get a random meal based on the distribution
                m = randomMeal(random.nextDouble());

                //Get a random destination
                d = map.get(random.nextInt(map.size()));

                if (m != null) {
                    //Create a new order
                    PlacedOrder ord = new PlacedOrder(curMin, d, names.get(randName), m);

                    //Add the order to the xml file
                    ord.addToXML(ordersFile);
                    if (test.size() < 5) {
                        test.add(ord);
                    }
                } else {
                    System.out.println("randomMeal is broken\n");
                }//m!=null

            } else { //If an order is not generated
                curMin++;
            }



        }

        //Add the xml closing for the orders file
        try{
            ordersFile = new File("Orders.xml"); //open the orders file
            FileWriter fileWriter = new FileWriter(ordersFile, true);
            PrintWriter printWriter = new PrintWriter(fileWriter);
            printWriter.println("</listOfOrders>");
            printWriter.close();
        } catch (Exception e) {
            System.out.println(e.getMessage());
        }

        System.out.println("Least cost distance of the subset of the first five orders is: " + TSP(test));
    }

    /**
     * Returns a random meal based on the distribution
     * @param rand A random double between 0 and 1
     * @return The meal that was randomly selected
     */
    private Meal randomMeal(double rand) {
        double counter = 0; //Keeps track of the distribution through the loop

        //Store the list of meals
        List<Meal> lm = defaultFood.getMeals();

        //Iterate to where the random number points to in the distribution
        for (int i = 0; i < lm.size(); i++) {
            counter += lm.get(i).getDistribution();
            if (rand < counter) {
                return lm.get(i); //return the meal selected
            }
        }

        //If it returns null the distribution invalid
        return null;
    }

    /**
     * Calculates the least cost distance to complete the delivery cycle
     * @param orders ArrayList of placed orders to travel and deliver food to
     * @return The least cost distance to complete the delivery cycle
     */
    public double TSP(ArrayList<PlacedOrder> orders) {
        ArrayList<Destination> locations = new ArrayList<>(); //The destination of each order

        //The place where the drone leaves and returns to
        Destination home = new Destination("Home", 0, 0, 0);

        //Seed the location ArrayList with each destination from the order list
        for (int i = 0; i < orders.size(); i++) {
            locations.add(orders.get(i).getDest());
        }

        //Call the recursive function which does the brunt work of the algorithm
        return recursiveTSP(locations, home);
    }

    /**
     * Does the brunt work of the TSP. Should run in O(n^2 * 2^n) which is much better than O(n!)
     * @param locations The locations yet to be visited
     * @param lastDest The last destination the algorithm visited
     * @return The least cost distance to visit all the locations and return
     */
    private double recursiveTSP(ArrayList<Destination> locations, Destination lastDest) {
        if (locations.size() == 0) { //base case
            return lastDest.getDist(); //return to home
        } else {
            double min = Double.MAX_VALUE; //minimum travel distance for given depth in the recursion tree

            //For each possible set of locations
            for (int d = 0; d < locations.size(); d++) {
                Destination newDest = locations.remove(0); //remove the destination

                //recurse: it finds the fastest route in the subset and then adds the distance between the current
                //          point and the subset. It then takes the minimum at the level so to help in the recursion in
                //          the level above it
                min = Math.min(min, recursiveTSP(locations, newDest) + lastDest.distanceBetween(newDest));

                //Add back the location because each iteration of the loop on the same level should have the same
                //number of locations to check
                locations.add(newDest);
            }
            //return the shortest distance found in the given level
            return min;
        }

    }




    public static DefaultFood getDefaultFood() {
        if (single_instance == null) {
            single_instance = new SimController();
        }
        return defaultFood;
    }


}
